// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 21 Jun 2021 16:17:37 CEST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package beagle_bindings

/*
#cgo LDFLAGS: -L${SRCDIR} -lstdc++
#cgo CFLAGS: -I. -DDEBUG -I${SRCDIR}/
#include "beagle.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocBeagleVersionMemory allocates memory for type C.BeagleVersion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleVersionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleVersionValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleVersionValue = unsafe.Sizeof([1]C.BeagleVersion{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleVersion) Ref() *C.BeagleVersion {
	if x == nil {
		return nil
	}
	return x.reffa4c6c5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleVersion) Free() {
	if x != nil && x.allocsfa4c6c5 != nil {
		x.allocsfa4c6c5.(*cgoAllocMap).Free()
		x.reffa4c6c5 = nil
	}
}

// NewBeagleVersionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleVersionRef(ref unsafe.Pointer) *BeagleVersion {
	if ref == nil {
		return nil
	}
	obj := new(BeagleVersion)
	obj.reffa4c6c5 = (*C.BeagleVersion)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleVersion) PassRef() (*C.BeagleVersion, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffa4c6c5 != nil {
		return x.reffa4c6c5, nil
	}
	memfa4c6c5 := allocBeagleVersionMemory(1)
	reffa4c6c5 := (*C.BeagleVersion)(memfa4c6c5)
	allocsfa4c6c5 := new(cgoAllocMap)
	allocsfa4c6c5.Add(memfa4c6c5)

	var csoftware_allocs *cgoAllocMap
	reffa4c6c5.software, csoftware_allocs = (C.u16)(x.Software), cgoAllocsUnknown
	allocsfa4c6c5.Borrow(csoftware_allocs)

	var cfirmware_allocs *cgoAllocMap
	reffa4c6c5.firmware, cfirmware_allocs = (C.u16)(x.Firmware), cgoAllocsUnknown
	allocsfa4c6c5.Borrow(cfirmware_allocs)

	var chardware_allocs *cgoAllocMap
	reffa4c6c5.hardware, chardware_allocs = (C.u16)(x.Hardware), cgoAllocsUnknown
	allocsfa4c6c5.Borrow(chardware_allocs)

	var chw_revs_for_sw_allocs *cgoAllocMap
	reffa4c6c5.hw_revs_for_sw, chw_revs_for_sw_allocs = (C.u32)(x.Hw_revs_for_sw), cgoAllocsUnknown
	allocsfa4c6c5.Borrow(chw_revs_for_sw_allocs)

	var cfw_revs_for_sw_allocs *cgoAllocMap
	reffa4c6c5.fw_revs_for_sw, cfw_revs_for_sw_allocs = (C.u32)(x.Fw_revs_for_sw), cgoAllocsUnknown
	allocsfa4c6c5.Borrow(cfw_revs_for_sw_allocs)

	var cdrv_revs_for_sw_allocs *cgoAllocMap
	reffa4c6c5.drv_revs_for_sw, cdrv_revs_for_sw_allocs = (C.u32)(x.Drv_revs_for_sw), cgoAllocsUnknown
	allocsfa4c6c5.Borrow(cdrv_revs_for_sw_allocs)

	var capi_req_by_sw_allocs *cgoAllocMap
	reffa4c6c5.api_req_by_sw, capi_req_by_sw_allocs = (C.u16)(x.Api_req_by_sw), cgoAllocsUnknown
	allocsfa4c6c5.Borrow(capi_req_by_sw_allocs)

	x.reffa4c6c5 = reffa4c6c5
	x.allocsfa4c6c5 = allocsfa4c6c5
	return reffa4c6c5, allocsfa4c6c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleVersion) PassValue() (C.BeagleVersion, *cgoAllocMap) {
	if x.reffa4c6c5 != nil {
		return *x.reffa4c6c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleVersion) Deref() {
	if x.reffa4c6c5 == nil {
		return
	}
	x.Software = (uint16)(x.reffa4c6c5.software)
	x.Firmware = (uint16)(x.reffa4c6c5.firmware)
	x.Hardware = (uint16)(x.reffa4c6c5.hardware)
	x.Hw_revs_for_sw = (uint32)(x.reffa4c6c5.hw_revs_for_sw)
	x.Fw_revs_for_sw = (uint32)(x.reffa4c6c5.fw_revs_for_sw)
	x.Drv_revs_for_sw = (uint32)(x.reffa4c6c5.drv_revs_for_sw)
	x.Api_req_by_sw = (uint16)(x.reffa4c6c5.api_req_by_sw)
}

// allocBeagleExtMemory allocates memory for type C.BeagleExt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleExtMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleExtValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleExtValue = unsafe.Sizeof([1]C.BeagleExt{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleExt) Ref() *C.BeagleExt {
	if x == nil {
		return nil
	}
	return x.ref20b37dce
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleExt) Free() {
	if x != nil && x.allocs20b37dce != nil {
		x.allocs20b37dce.(*cgoAllocMap).Free()
		x.ref20b37dce = nil
	}
}

// NewBeagleExtRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleExtRef(ref unsafe.Pointer) *BeagleExt {
	if ref == nil {
		return nil
	}
	obj := new(BeagleExt)
	obj.ref20b37dce = (*C.BeagleExt)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleExt) PassRef() (*C.BeagleExt, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref20b37dce != nil {
		return x.ref20b37dce, nil
	}
	mem20b37dce := allocBeagleExtMemory(1)
	ref20b37dce := (*C.BeagleExt)(mem20b37dce)
	allocs20b37dce := new(cgoAllocMap)
	allocs20b37dce.Add(mem20b37dce)

	var cversion_allocs *cgoAllocMap
	ref20b37dce.version, cversion_allocs = x.Version.PassValue()
	allocs20b37dce.Borrow(cversion_allocs)

	var cfeatures_allocs *cgoAllocMap
	ref20b37dce.features, cfeatures_allocs = (C.int)(x.Features), cgoAllocsUnknown
	allocs20b37dce.Borrow(cfeatures_allocs)

	x.ref20b37dce = ref20b37dce
	x.allocs20b37dce = allocs20b37dce
	return ref20b37dce, allocs20b37dce

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleExt) PassValue() (C.BeagleExt, *cgoAllocMap) {
	if x.ref20b37dce != nil {
		return *x.ref20b37dce, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleExt) Deref() {
	if x.ref20b37dce == nil {
		return
	}
	x.Version = *NewBeagleVersionRef(unsafe.Pointer(&x.ref20b37dce.version))
	x.Features = (int32)(x.ref20b37dce.features)
}

// allocBeagleUsb2PacketMatchMemory allocates memory for type C.BeagleUsb2PacketMatch in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2PacketMatchMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2PacketMatchValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2PacketMatchValue = unsafe.Sizeof([1]C.BeagleUsb2PacketMatch{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2PacketMatch) Ref() *C.BeagleUsb2PacketMatch {
	if x == nil {
		return nil
	}
	return x.ref6d1d975d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2PacketMatch) Free() {
	if x != nil && x.allocs6d1d975d != nil {
		x.allocs6d1d975d.(*cgoAllocMap).Free()
		x.ref6d1d975d = nil
	}
}

// NewBeagleUsb2PacketMatchRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2PacketMatchRef(ref unsafe.Pointer) *BeagleUsb2PacketMatch {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2PacketMatch)
	obj.ref6d1d975d = (*C.BeagleUsb2PacketMatch)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2PacketMatch) PassRef() (*C.BeagleUsb2PacketMatch, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d1d975d != nil {
		return x.ref6d1d975d, nil
	}
	mem6d1d975d := allocBeagleUsb2PacketMatchMemory(1)
	ref6d1d975d := (*C.BeagleUsb2PacketMatch)(mem6d1d975d)
	allocs6d1d975d := new(cgoAllocMap)
	allocs6d1d975d.Add(mem6d1d975d)

	var cpid_match_type_allocs *cgoAllocMap
	ref6d1d975d.pid_match_type, cpid_match_type_allocs = (C.BeagleUsb2MatchType)(x.Pid_match_type), cgoAllocsUnknown
	allocs6d1d975d.Borrow(cpid_match_type_allocs)

	var cpid_match_val_allocs *cgoAllocMap
	ref6d1d975d.pid_match_val, cpid_match_val_allocs = (C.u08)(x.Pid_match_val), cgoAllocsUnknown
	allocs6d1d975d.Borrow(cpid_match_val_allocs)

	var cdev_match_type_allocs *cgoAllocMap
	ref6d1d975d.dev_match_type, cdev_match_type_allocs = (C.BeagleUsb2MatchType)(x.Dev_match_type), cgoAllocsUnknown
	allocs6d1d975d.Borrow(cdev_match_type_allocs)

	var cdev_match_val_allocs *cgoAllocMap
	ref6d1d975d.dev_match_val, cdev_match_val_allocs = (C.u08)(x.Dev_match_val), cgoAllocsUnknown
	allocs6d1d975d.Borrow(cdev_match_val_allocs)

	var cep_match_type_allocs *cgoAllocMap
	ref6d1d975d.ep_match_type, cep_match_type_allocs = (C.BeagleUsb2MatchType)(x.Ep_match_type), cgoAllocsUnknown
	allocs6d1d975d.Borrow(cep_match_type_allocs)

	var cep_match_val_allocs *cgoAllocMap
	ref6d1d975d.ep_match_val, cep_match_val_allocs = (C.u08)(x.Ep_match_val), cgoAllocsUnknown
	allocs6d1d975d.Borrow(cep_match_val_allocs)

	x.ref6d1d975d = ref6d1d975d
	x.allocs6d1d975d = allocs6d1d975d
	return ref6d1d975d, allocs6d1d975d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2PacketMatch) PassValue() (C.BeagleUsb2PacketMatch, *cgoAllocMap) {
	if x.ref6d1d975d != nil {
		return *x.ref6d1d975d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2PacketMatch) Deref() {
	if x.ref6d1d975d == nil {
		return
	}
	x.Pid_match_type = (BeagleUsb2MatchType)(x.ref6d1d975d.pid_match_type)
	x.Pid_match_val = (byte)(x.ref6d1d975d.pid_match_val)
	x.Dev_match_type = (BeagleUsb2MatchType)(x.ref6d1d975d.dev_match_type)
	x.Dev_match_val = (byte)(x.ref6d1d975d.dev_match_val)
	x.Ep_match_type = (BeagleUsb2MatchType)(x.ref6d1d975d.ep_match_type)
	x.Ep_match_val = (byte)(x.ref6d1d975d.ep_match_val)
}

// allocBeagleUsb2DataMatchMemory allocates memory for type C.BeagleUsb2DataMatch in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2DataMatchMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2DataMatchValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2DataMatchValue = unsafe.Sizeof([1]C.BeagleUsb2DataMatch{})

// copyPU08Bytes copies the data from Go slice as *C.u08.
func copyPU08Bytes(slice *sliceHeader) (*C.u08, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfU08Value) * slice.Len,
		Cap:  int(sizeOfU08Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.u08)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocU08Memory allocates memory for type C.u08 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocU08Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfU08Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfU08Value = unsafe.Sizeof([1]C.u08{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2DataMatch) Ref() *C.BeagleUsb2DataMatch {
	if x == nil {
		return nil
	}
	return x.refc50c0392
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2DataMatch) Free() {
	if x != nil && x.allocsc50c0392 != nil {
		x.allocsc50c0392.(*cgoAllocMap).Free()
		x.refc50c0392 = nil
	}
}

// NewBeagleUsb2DataMatchRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2DataMatchRef(ref unsafe.Pointer) *BeagleUsb2DataMatch {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2DataMatch)
	obj.refc50c0392 = (*C.BeagleUsb2DataMatch)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2DataMatch) PassRef() (*C.BeagleUsb2DataMatch, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc50c0392 != nil {
		return x.refc50c0392, nil
	}
	memc50c0392 := allocBeagleUsb2DataMatchMemory(1)
	refc50c0392 := (*C.BeagleUsb2DataMatch)(memc50c0392)
	allocsc50c0392 := new(cgoAllocMap)
	allocsc50c0392.Add(memc50c0392)

	var cdata_match_type_allocs *cgoAllocMap
	refc50c0392.data_match_type, cdata_match_type_allocs = (C.BeagleUsb2MatchType)(x.Data_match_type), cgoAllocsUnknown
	allocsc50c0392.Borrow(cdata_match_type_allocs)

	var cdata_match_pid_allocs *cgoAllocMap
	refc50c0392.data_match_pid, cdata_match_pid_allocs = (C.u08)(x.Data_match_pid), cgoAllocsUnknown
	allocsc50c0392.Borrow(cdata_match_pid_allocs)

	var cdata_length_allocs *cgoAllocMap
	refc50c0392.data_length, cdata_length_allocs = (C.u16)(x.Data_length), cgoAllocsUnknown
	allocsc50c0392.Borrow(cdata_length_allocs)

	var cdata_allocs *cgoAllocMap
	refc50c0392.data, cdata_allocs = copyPU08Bytes((*sliceHeader)(unsafe.Pointer(&x.Data)))
	allocsc50c0392.Borrow(cdata_allocs)

	var cdata_valid_length_allocs *cgoAllocMap
	refc50c0392.data_valid_length, cdata_valid_length_allocs = (C.u16)(x.Data_valid_length), cgoAllocsUnknown
	allocsc50c0392.Borrow(cdata_valid_length_allocs)

	var cdata_valid_allocs *cgoAllocMap
	refc50c0392.data_valid, cdata_valid_allocs = copyPU08Bytes((*sliceHeader)(unsafe.Pointer(&x.Data_valid)))
	allocsc50c0392.Borrow(cdata_valid_allocs)

	x.refc50c0392 = refc50c0392
	x.allocsc50c0392 = allocsc50c0392
	return refc50c0392, allocsc50c0392

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2DataMatch) PassValue() (C.BeagleUsb2DataMatch, *cgoAllocMap) {
	if x.refc50c0392 != nil {
		return *x.refc50c0392, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2DataMatch) Deref() {
	if x.refc50c0392 == nil {
		return
	}
	x.Data_match_type = (BeagleUsb2MatchType)(x.refc50c0392.data_match_type)
	x.Data_match_pid = (byte)(x.refc50c0392.data_match_pid)
	x.Data_length = (uint16)(x.refc50c0392.data_length)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxfc4425b.Data = unsafe.Pointer(x.refc50c0392.data)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Data_valid_length = (uint16)(x.refc50c0392.data_valid_length)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Data_valid))
	hxf95e7c8.Data = unsafe.Pointer(x.refc50c0392.data_valid)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

}

// allocBeagleUsb2DataPropertiesMemory allocates memory for type C.BeagleUsb2DataProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2DataPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2DataPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2DataPropertiesValue = unsafe.Sizeof([1]C.BeagleUsb2DataProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2DataProperties) Ref() *C.BeagleUsb2DataProperties {
	if x == nil {
		return nil
	}
	return x.refbd6df15f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2DataProperties) Free() {
	if x != nil && x.allocsbd6df15f != nil {
		x.allocsbd6df15f.(*cgoAllocMap).Free()
		x.refbd6df15f = nil
	}
}

// NewBeagleUsb2DataPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2DataPropertiesRef(ref unsafe.Pointer) *BeagleUsb2DataProperties {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2DataProperties)
	obj.refbd6df15f = (*C.BeagleUsb2DataProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2DataProperties) PassRef() (*C.BeagleUsb2DataProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd6df15f != nil {
		return x.refbd6df15f, nil
	}
	membd6df15f := allocBeagleUsb2DataPropertiesMemory(1)
	refbd6df15f := (*C.BeagleUsb2DataProperties)(membd6df15f)
	allocsbd6df15f := new(cgoAllocMap)
	allocsbd6df15f.Add(membd6df15f)

	var cdirection_allocs *cgoAllocMap
	refbd6df15f.direction, cdirection_allocs = (C.BeagleUsb2DataMatchDirection)(x.Direction), cgoAllocsUnknown
	allocsbd6df15f.Borrow(cdirection_allocs)

	var cep_match_type_allocs *cgoAllocMap
	refbd6df15f.ep_match_type, cep_match_type_allocs = (C.BeagleUsbMatchType)(x.Ep_match_type), cgoAllocsUnknown
	allocsbd6df15f.Borrow(cep_match_type_allocs)

	var cep_match_val_allocs *cgoAllocMap
	refbd6df15f.ep_match_val, cep_match_val_allocs = (C.u08)(x.Ep_match_val), cgoAllocsUnknown
	allocsbd6df15f.Borrow(cep_match_val_allocs)

	var cdev_match_type_allocs *cgoAllocMap
	refbd6df15f.dev_match_type, cdev_match_type_allocs = (C.BeagleUsbMatchType)(x.Dev_match_type), cgoAllocsUnknown
	allocsbd6df15f.Borrow(cdev_match_type_allocs)

	var cdev_match_val_allocs *cgoAllocMap
	refbd6df15f.dev_match_val, cdev_match_val_allocs = (C.u08)(x.Dev_match_val), cgoAllocsUnknown
	allocsbd6df15f.Borrow(cdev_match_val_allocs)

	var cdata_len_match_type_allocs *cgoAllocMap
	refbd6df15f.data_len_match_type, cdata_len_match_type_allocs = (C.BeagleUsbMatchType)(x.Data_len_match_type), cgoAllocsUnknown
	allocsbd6df15f.Borrow(cdata_len_match_type_allocs)

	var cdata_len_match_val_allocs *cgoAllocMap
	refbd6df15f.data_len_match_val, cdata_len_match_val_allocs = (C.u16)(x.Data_len_match_val), cgoAllocsUnknown
	allocsbd6df15f.Borrow(cdata_len_match_val_allocs)

	x.refbd6df15f = refbd6df15f
	x.allocsbd6df15f = allocsbd6df15f
	return refbd6df15f, allocsbd6df15f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2DataProperties) PassValue() (C.BeagleUsb2DataProperties, *cgoAllocMap) {
	if x.refbd6df15f != nil {
		return *x.refbd6df15f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2DataProperties) Deref() {
	if x.refbd6df15f == nil {
		return
	}
	x.Direction = (BeagleUsb2DataMatchDirection)(x.refbd6df15f.direction)
	x.Ep_match_type = (BeagleUsbMatchType)(x.refbd6df15f.ep_match_type)
	x.Ep_match_val = (byte)(x.refbd6df15f.ep_match_val)
	x.Dev_match_type = (BeagleUsbMatchType)(x.refbd6df15f.dev_match_type)
	x.Dev_match_val = (byte)(x.refbd6df15f.dev_match_val)
	x.Data_len_match_type = (BeagleUsbMatchType)(x.refbd6df15f.data_len_match_type)
	x.Data_len_match_val = (uint16)(x.refbd6df15f.data_len_match_val)
}

// allocBeagleUsb2DataMatchUnitMemory allocates memory for type C.BeagleUsb2DataMatchUnit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2DataMatchUnitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2DataMatchUnitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2DataMatchUnitValue = unsafe.Sizeof([1]C.BeagleUsb2DataMatchUnit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2DataMatchUnit) Ref() *C.BeagleUsb2DataMatchUnit {
	if x == nil {
		return nil
	}
	return x.ref2e3d4d28
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2DataMatchUnit) Free() {
	if x != nil && x.allocs2e3d4d28 != nil {
		x.allocs2e3d4d28.(*cgoAllocMap).Free()
		x.ref2e3d4d28 = nil
	}
}

// NewBeagleUsb2DataMatchUnitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2DataMatchUnitRef(ref unsafe.Pointer) *BeagleUsb2DataMatchUnit {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2DataMatchUnit)
	obj.ref2e3d4d28 = (*C.BeagleUsb2DataMatchUnit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2DataMatchUnit) PassRef() (*C.BeagleUsb2DataMatchUnit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2e3d4d28 != nil {
		return x.ref2e3d4d28, nil
	}
	mem2e3d4d28 := allocBeagleUsb2DataMatchUnitMemory(1)
	ref2e3d4d28 := (*C.BeagleUsb2DataMatchUnit)(mem2e3d4d28)
	allocs2e3d4d28 := new(cgoAllocMap)
	allocs2e3d4d28.Add(mem2e3d4d28)

	var cpacket_type_allocs *cgoAllocMap
	ref2e3d4d28.packet_type, cpacket_type_allocs = (C.BeagleUsb2PacketType)(x.Packet_type), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cpacket_type_allocs)

	var cprefix_allocs *cgoAllocMap
	ref2e3d4d28.prefix, cprefix_allocs = (C.BeagleUsb2DataMatchPrefix)(x.Prefix), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cprefix_allocs)

	var chandshake_allocs *cgoAllocMap
	ref2e3d4d28.handshake, chandshake_allocs = (C.u08)(x.Handshake), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(chandshake_allocs)

	var cdata_length_allocs *cgoAllocMap
	ref2e3d4d28.data_length, cdata_length_allocs = (C.u16)(x.Data_length), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cdata_length_allocs)

	var cdata_allocs *cgoAllocMap
	ref2e3d4d28.data, cdata_allocs = *(**C.u08)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cdata_allocs)

	var cdata_valid_length_allocs *cgoAllocMap
	ref2e3d4d28.data_valid_length, cdata_valid_length_allocs = (C.u16)(x.Data_valid_length), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cdata_valid_length_allocs)

	var cdata_valid_allocs *cgoAllocMap
	ref2e3d4d28.data_valid, cdata_valid_allocs = copyPU08Bytes((*sliceHeader)(unsafe.Pointer(&x.Data_valid)))
	allocs2e3d4d28.Borrow(cdata_valid_allocs)

	var cerr_match_allocs *cgoAllocMap
	ref2e3d4d28.err_match, cerr_match_allocs = (C.BeagleUsb2ErrorType)(x.Err_match), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cerr_match_allocs)

	var cdata_properties_valid_allocs *cgoAllocMap
	ref2e3d4d28.data_properties_valid, cdata_properties_valid_allocs = (C.u08)(x.Data_properties_valid), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cdata_properties_valid_allocs)

	var cdata_properties_allocs *cgoAllocMap
	ref2e3d4d28.data_properties, cdata_properties_allocs = x.Data_properties.PassValue()
	allocs2e3d4d28.Borrow(cdata_properties_allocs)

	var cmatch_modifier_allocs *cgoAllocMap
	ref2e3d4d28.match_modifier, cmatch_modifier_allocs = (C.BeagleUsb2MatchModifier)(x.Match_modifier), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cmatch_modifier_allocs)

	var crepeat_count_allocs *cgoAllocMap
	ref2e3d4d28.repeat_count, crepeat_count_allocs = (C.u16)(x.Repeat_count), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(crepeat_count_allocs)

	var csticky_action_allocs *cgoAllocMap
	ref2e3d4d28.sticky_action, csticky_action_allocs = (C.u08)(x.Sticky_action), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(csticky_action_allocs)

	var caction_mask_allocs *cgoAllocMap
	ref2e3d4d28.action_mask, caction_mask_allocs = (C.u08)(x.Action_mask), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(caction_mask_allocs)

	var cgoto_selector_allocs *cgoAllocMap
	ref2e3d4d28.goto_selector, cgoto_selector_allocs = (C.u08)(x.Goto_selector), cgoAllocsUnknown
	allocs2e3d4d28.Borrow(cgoto_selector_allocs)

	x.ref2e3d4d28 = ref2e3d4d28
	x.allocs2e3d4d28 = allocs2e3d4d28
	return ref2e3d4d28, allocs2e3d4d28

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2DataMatchUnit) PassValue() (C.BeagleUsb2DataMatchUnit, *cgoAllocMap) {
	if x.ref2e3d4d28 != nil {
		return *x.ref2e3d4d28, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2DataMatchUnit) Deref() {
	if x.ref2e3d4d28 == nil {
		return
	}
	x.Packet_type = (BeagleUsb2PacketType)(x.ref2e3d4d28.packet_type)
	x.Prefix = (BeagleUsb2DataMatchPrefix)(x.ref2e3d4d28.prefix)
	x.Handshake = (byte)(x.ref2e3d4d28.handshake)
	x.Data_length = (uint16)(x.ref2e3d4d28.data_length)
	x.Data = (*byte)(unsafe.Pointer(x.ref2e3d4d28.data))
	x.Data_valid_length = (uint16)(x.ref2e3d4d28.data_valid_length)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.Data_valid))
	hxff2234b.Data = unsafe.Pointer(x.ref2e3d4d28.data_valid)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.Err_match = (BeagleUsb2ErrorType)(x.ref2e3d4d28.err_match)
	x.Data_properties_valid = (byte)(x.ref2e3d4d28.data_properties_valid)
	x.Data_properties = *NewBeagleUsb2DataPropertiesRef(unsafe.Pointer(&x.ref2e3d4d28.data_properties))
	x.Match_modifier = (BeagleUsb2MatchModifier)(x.ref2e3d4d28.match_modifier)
	x.Repeat_count = (uint16)(x.ref2e3d4d28.repeat_count)
	x.Sticky_action = (byte)(x.ref2e3d4d28.sticky_action)
	x.Action_mask = (byte)(x.ref2e3d4d28.action_mask)
	x.Goto_selector = (byte)(x.ref2e3d4d28.goto_selector)
}

// allocBeagleUsb2TimerMatchUnitMemory allocates memory for type C.BeagleUsb2TimerMatchUnit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2TimerMatchUnitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2TimerMatchUnitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2TimerMatchUnitValue = unsafe.Sizeof([1]C.BeagleUsb2TimerMatchUnit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2TimerMatchUnit) Ref() *C.BeagleUsb2TimerMatchUnit {
	if x == nil {
		return nil
	}
	return x.ref28483831
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2TimerMatchUnit) Free() {
	if x != nil && x.allocs28483831 != nil {
		x.allocs28483831.(*cgoAllocMap).Free()
		x.ref28483831 = nil
	}
}

// NewBeagleUsb2TimerMatchUnitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2TimerMatchUnitRef(ref unsafe.Pointer) *BeagleUsb2TimerMatchUnit {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2TimerMatchUnit)
	obj.ref28483831 = (*C.BeagleUsb2TimerMatchUnit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2TimerMatchUnit) PassRef() (*C.BeagleUsb2TimerMatchUnit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28483831 != nil {
		return x.ref28483831, nil
	}
	mem28483831 := allocBeagleUsb2TimerMatchUnitMemory(1)
	ref28483831 := (*C.BeagleUsb2TimerMatchUnit)(mem28483831)
	allocs28483831 := new(cgoAllocMap)
	allocs28483831.Add(mem28483831)

	var ctimer_unit_allocs *cgoAllocMap
	ref28483831.timer_unit, ctimer_unit_allocs = (C.BeagleUsbTimerUnit)(x.Timer_unit), cgoAllocsUnknown
	allocs28483831.Borrow(ctimer_unit_allocs)

	var ctimer_val_allocs *cgoAllocMap
	ref28483831.timer_val, ctimer_val_allocs = (C.u32)(x.Timer_val), cgoAllocsUnknown
	allocs28483831.Borrow(ctimer_val_allocs)

	var caction_mask_allocs *cgoAllocMap
	ref28483831.action_mask, caction_mask_allocs = (C.u08)(x.Action_mask), cgoAllocsUnknown
	allocs28483831.Borrow(caction_mask_allocs)

	var cgoto_selector_allocs *cgoAllocMap
	ref28483831.goto_selector, cgoto_selector_allocs = (C.u08)(x.Goto_selector), cgoAllocsUnknown
	allocs28483831.Borrow(cgoto_selector_allocs)

	x.ref28483831 = ref28483831
	x.allocs28483831 = allocs28483831
	return ref28483831, allocs28483831

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2TimerMatchUnit) PassValue() (C.BeagleUsb2TimerMatchUnit, *cgoAllocMap) {
	if x.ref28483831 != nil {
		return *x.ref28483831, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2TimerMatchUnit) Deref() {
	if x.ref28483831 == nil {
		return
	}
	x.Timer_unit = (BeagleUsbTimerUnit)(x.ref28483831.timer_unit)
	x.Timer_val = (uint32)(x.ref28483831.timer_val)
	x.Action_mask = (byte)(x.ref28483831.action_mask)
	x.Goto_selector = (byte)(x.ref28483831.goto_selector)
}

// allocBeagleUsb2AsyncEventMatchUnitMemory allocates memory for type C.BeagleUsb2AsyncEventMatchUnit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2AsyncEventMatchUnitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2AsyncEventMatchUnitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2AsyncEventMatchUnitValue = unsafe.Sizeof([1]C.BeagleUsb2AsyncEventMatchUnit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2AsyncEventMatchUnit) Ref() *C.BeagleUsb2AsyncEventMatchUnit {
	if x == nil {
		return nil
	}
	return x.ref2726746b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2AsyncEventMatchUnit) Free() {
	if x != nil && x.allocs2726746b != nil {
		x.allocs2726746b.(*cgoAllocMap).Free()
		x.ref2726746b = nil
	}
}

// NewBeagleUsb2AsyncEventMatchUnitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2AsyncEventMatchUnitRef(ref unsafe.Pointer) *BeagleUsb2AsyncEventMatchUnit {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2AsyncEventMatchUnit)
	obj.ref2726746b = (*C.BeagleUsb2AsyncEventMatchUnit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2AsyncEventMatchUnit) PassRef() (*C.BeagleUsb2AsyncEventMatchUnit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2726746b != nil {
		return x.ref2726746b, nil
	}
	mem2726746b := allocBeagleUsb2AsyncEventMatchUnitMemory(1)
	ref2726746b := (*C.BeagleUsb2AsyncEventMatchUnit)(mem2726746b)
	allocs2726746b := new(cgoAllocMap)
	allocs2726746b.Add(mem2726746b)

	var cevent_type_allocs *cgoAllocMap
	ref2726746b.event_type, cevent_type_allocs = (C.BeagleUsb2AsyncEventType)(x.Event_type), cgoAllocsUnknown
	allocs2726746b.Borrow(cevent_type_allocs)

	var cedge_mask_allocs *cgoAllocMap
	ref2726746b.edge_mask, cedge_mask_allocs = (C.u08)(x.Edge_mask), cgoAllocsUnknown
	allocs2726746b.Borrow(cedge_mask_allocs)

	var crepeat_count_allocs *cgoAllocMap
	ref2726746b.repeat_count, crepeat_count_allocs = (C.u16)(x.Repeat_count), cgoAllocsUnknown
	allocs2726746b.Borrow(crepeat_count_allocs)

	var csticky_action_allocs *cgoAllocMap
	ref2726746b.sticky_action, csticky_action_allocs = (C.u08)(x.Sticky_action), cgoAllocsUnknown
	allocs2726746b.Borrow(csticky_action_allocs)

	var caction_mask_allocs *cgoAllocMap
	ref2726746b.action_mask, caction_mask_allocs = (C.u08)(x.Action_mask), cgoAllocsUnknown
	allocs2726746b.Borrow(caction_mask_allocs)

	var cgoto_selector_allocs *cgoAllocMap
	ref2726746b.goto_selector, cgoto_selector_allocs = (C.u08)(x.Goto_selector), cgoAllocsUnknown
	allocs2726746b.Borrow(cgoto_selector_allocs)

	var cvbus_trigger_type_allocs *cgoAllocMap
	ref2726746b.vbus_trigger_type, cvbus_trigger_type_allocs = (C.BeagleUsb2VbusTriggerType)(x.Vbus_trigger_type), cgoAllocsUnknown
	allocs2726746b.Borrow(cvbus_trigger_type_allocs)

	var cvbus_trigger_val_allocs *cgoAllocMap
	ref2726746b.vbus_trigger_val, cvbus_trigger_val_allocs = (C.f32)(x.Vbus_trigger_val), cgoAllocsUnknown
	allocs2726746b.Borrow(cvbus_trigger_val_allocs)

	x.ref2726746b = ref2726746b
	x.allocs2726746b = allocs2726746b
	return ref2726746b, allocs2726746b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2AsyncEventMatchUnit) PassValue() (C.BeagleUsb2AsyncEventMatchUnit, *cgoAllocMap) {
	if x.ref2726746b != nil {
		return *x.ref2726746b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2AsyncEventMatchUnit) Deref() {
	if x.ref2726746b == nil {
		return
	}
	x.Event_type = (BeagleUsb2AsyncEventType)(x.ref2726746b.event_type)
	x.Edge_mask = (byte)(x.ref2726746b.edge_mask)
	x.Repeat_count = (uint16)(x.ref2726746b.repeat_count)
	x.Sticky_action = (byte)(x.ref2726746b.sticky_action)
	x.Action_mask = (byte)(x.ref2726746b.action_mask)
	x.Goto_selector = (byte)(x.ref2726746b.goto_selector)
	x.Vbus_trigger_type = (BeagleUsb2VbusTriggerType)(x.ref2726746b.vbus_trigger_type)
	x.Vbus_trigger_val = (float32)(x.ref2726746b.vbus_trigger_val)
}

// allocBeagleUsb2ComplexMatchStateMemory allocates memory for type C.BeagleUsb2ComplexMatchState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2ComplexMatchStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2ComplexMatchStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2ComplexMatchStateValue = unsafe.Sizeof([1]C.BeagleUsb2ComplexMatchState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2ComplexMatchState) Ref() *C.BeagleUsb2ComplexMatchState {
	if x == nil {
		return nil
	}
	return x.refeeb5fe45
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2ComplexMatchState) Free() {
	if x != nil && x.allocseeb5fe45 != nil {
		x.allocseeb5fe45.(*cgoAllocMap).Free()
		x.refeeb5fe45 = nil
	}
}

// NewBeagleUsb2ComplexMatchStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2ComplexMatchStateRef(ref unsafe.Pointer) *BeagleUsb2ComplexMatchState {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2ComplexMatchState)
	obj.refeeb5fe45 = (*C.BeagleUsb2ComplexMatchState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2ComplexMatchState) PassRef() (*C.BeagleUsb2ComplexMatchState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeeb5fe45 != nil {
		return x.refeeb5fe45, nil
	}
	memeeb5fe45 := allocBeagleUsb2ComplexMatchStateMemory(1)
	refeeb5fe45 := (*C.BeagleUsb2ComplexMatchState)(memeeb5fe45)
	allocseeb5fe45 := new(cgoAllocMap)
	allocseeb5fe45.Add(memeeb5fe45)

	var cdata_0_valid_allocs *cgoAllocMap
	refeeb5fe45.data_0_valid, cdata_0_valid_allocs = (C.u08)(x.Data_0_valid), cgoAllocsUnknown
	allocseeb5fe45.Borrow(cdata_0_valid_allocs)

	var cdata_0_match_allocs *cgoAllocMap
	refeeb5fe45.data_0_match, cdata_0_match_allocs = x.Data_0_match.PassValue()
	allocseeb5fe45.Borrow(cdata_0_match_allocs)

	var cdata_1_valid_allocs *cgoAllocMap
	refeeb5fe45.data_1_valid, cdata_1_valid_allocs = (C.u08)(x.Data_1_valid), cgoAllocsUnknown
	allocseeb5fe45.Borrow(cdata_1_valid_allocs)

	var cdata_1_match_allocs *cgoAllocMap
	refeeb5fe45.data_1_match, cdata_1_match_allocs = x.Data_1_match.PassValue()
	allocseeb5fe45.Borrow(cdata_1_match_allocs)

	var cdata_2_valid_allocs *cgoAllocMap
	refeeb5fe45.data_2_valid, cdata_2_valid_allocs = (C.u08)(x.Data_2_valid), cgoAllocsUnknown
	allocseeb5fe45.Borrow(cdata_2_valid_allocs)

	var cdata_2_match_allocs *cgoAllocMap
	refeeb5fe45.data_2_match, cdata_2_match_allocs = x.Data_2_match.PassValue()
	allocseeb5fe45.Borrow(cdata_2_match_allocs)

	var cdata_3_valid_allocs *cgoAllocMap
	refeeb5fe45.data_3_valid, cdata_3_valid_allocs = (C.u08)(x.Data_3_valid), cgoAllocsUnknown
	allocseeb5fe45.Borrow(cdata_3_valid_allocs)

	var cdata_3_match_allocs *cgoAllocMap
	refeeb5fe45.data_3_match, cdata_3_match_allocs = x.Data_3_match.PassValue()
	allocseeb5fe45.Borrow(cdata_3_match_allocs)

	var ctimer_valid_allocs *cgoAllocMap
	refeeb5fe45.timer_valid, ctimer_valid_allocs = (C.u08)(x.Timer_valid), cgoAllocsUnknown
	allocseeb5fe45.Borrow(ctimer_valid_allocs)

	var ctimer_match_allocs *cgoAllocMap
	refeeb5fe45.timer_match, ctimer_match_allocs = x.Timer_match.PassValue()
	allocseeb5fe45.Borrow(ctimer_match_allocs)

	var casync_valid_allocs *cgoAllocMap
	refeeb5fe45.async_valid, casync_valid_allocs = (C.u08)(x.Async_valid), cgoAllocsUnknown
	allocseeb5fe45.Borrow(casync_valid_allocs)

	var casync_match_allocs *cgoAllocMap
	refeeb5fe45.async_match, casync_match_allocs = x.Async_match.PassValue()
	allocseeb5fe45.Borrow(casync_match_allocs)

	var cgoto_0_allocs *cgoAllocMap
	refeeb5fe45.goto_0, cgoto_0_allocs = (C.u08)(x.Goto_0), cgoAllocsUnknown
	allocseeb5fe45.Borrow(cgoto_0_allocs)

	var cgoto_1_allocs *cgoAllocMap
	refeeb5fe45.goto_1, cgoto_1_allocs = (C.u08)(x.Goto_1), cgoAllocsUnknown
	allocseeb5fe45.Borrow(cgoto_1_allocs)

	var cgoto_2_allocs *cgoAllocMap
	refeeb5fe45.goto_2, cgoto_2_allocs = (C.u08)(x.Goto_2), cgoAllocsUnknown
	allocseeb5fe45.Borrow(cgoto_2_allocs)

	x.refeeb5fe45 = refeeb5fe45
	x.allocseeb5fe45 = allocseeb5fe45
	return refeeb5fe45, allocseeb5fe45

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2ComplexMatchState) PassValue() (C.BeagleUsb2ComplexMatchState, *cgoAllocMap) {
	if x.refeeb5fe45 != nil {
		return *x.refeeb5fe45, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2ComplexMatchState) Deref() {
	if x.refeeb5fe45 == nil {
		return
	}
	x.Data_0_valid = (byte)(x.refeeb5fe45.data_0_valid)
	x.Data_0_match = *NewBeagleUsb2DataMatchUnitRef(unsafe.Pointer(&x.refeeb5fe45.data_0_match))
	x.Data_1_valid = (byte)(x.refeeb5fe45.data_1_valid)
	x.Data_1_match = *NewBeagleUsb2DataMatchUnitRef(unsafe.Pointer(&x.refeeb5fe45.data_1_match))
	x.Data_2_valid = (byte)(x.refeeb5fe45.data_2_valid)
	x.Data_2_match = *NewBeagleUsb2DataMatchUnitRef(unsafe.Pointer(&x.refeeb5fe45.data_2_match))
	x.Data_3_valid = (byte)(x.refeeb5fe45.data_3_valid)
	x.Data_3_match = *NewBeagleUsb2DataMatchUnitRef(unsafe.Pointer(&x.refeeb5fe45.data_3_match))
	x.Timer_valid = (byte)(x.refeeb5fe45.timer_valid)
	x.Timer_match = *NewBeagleUsb2TimerMatchUnitRef(unsafe.Pointer(&x.refeeb5fe45.timer_match))
	x.Async_valid = (byte)(x.refeeb5fe45.async_valid)
	x.Async_match = *NewBeagleUsb2AsyncEventMatchUnitRef(unsafe.Pointer(&x.refeeb5fe45.async_match))
	x.Goto_0 = (byte)(x.refeeb5fe45.goto_0)
	x.Goto_1 = (byte)(x.refeeb5fe45.goto_1)
	x.Goto_2 = (byte)(x.refeeb5fe45.goto_2)
}

// allocBeagleUsb3ChannelMemory allocates memory for type C.BeagleUsb3Channel in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3ChannelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3ChannelValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3ChannelValue = unsafe.Sizeof([1]C.BeagleUsb3Channel{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3Channel) Ref() *C.BeagleUsb3Channel {
	if x == nil {
		return nil
	}
	return x.refa8884da4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3Channel) Free() {
	if x != nil && x.allocsa8884da4 != nil {
		x.allocsa8884da4.(*cgoAllocMap).Free()
		x.refa8884da4 = nil
	}
}

// NewBeagleUsb3ChannelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3ChannelRef(ref unsafe.Pointer) *BeagleUsb3Channel {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3Channel)
	obj.refa8884da4 = (*C.BeagleUsb3Channel)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3Channel) PassRef() (*C.BeagleUsb3Channel, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8884da4 != nil {
		return x.refa8884da4, nil
	}
	mema8884da4 := allocBeagleUsb3ChannelMemory(1)
	refa8884da4 := (*C.BeagleUsb3Channel)(mema8884da4)
	allocsa8884da4 := new(cgoAllocMap)
	allocsa8884da4.Add(mema8884da4)

	var cinput_equalization_short_allocs *cgoAllocMap
	refa8884da4.input_equalization_short, cinput_equalization_short_allocs = (C.u08)(x.Input_equalization_short), cgoAllocsUnknown
	allocsa8884da4.Borrow(cinput_equalization_short_allocs)

	var cinput_equalization_medium_allocs *cgoAllocMap
	refa8884da4.input_equalization_medium, cinput_equalization_medium_allocs = (C.u08)(x.Input_equalization_medium), cgoAllocsUnknown
	allocsa8884da4.Borrow(cinput_equalization_medium_allocs)

	var cinput_equalization_long_allocs *cgoAllocMap
	refa8884da4.input_equalization_long, cinput_equalization_long_allocs = (C.u08)(x.Input_equalization_long), cgoAllocsUnknown
	allocsa8884da4.Borrow(cinput_equalization_long_allocs)

	var cpre_emphasis_short_level_allocs *cgoAllocMap
	refa8884da4.pre_emphasis_short_level, cpre_emphasis_short_level_allocs = (C.u08)(x.Pre_emphasis_short_level), cgoAllocsUnknown
	allocsa8884da4.Borrow(cpre_emphasis_short_level_allocs)

	var cpre_emphasis_short_decay_allocs *cgoAllocMap
	refa8884da4.pre_emphasis_short_decay, cpre_emphasis_short_decay_allocs = (C.u08)(x.Pre_emphasis_short_decay), cgoAllocsUnknown
	allocsa8884da4.Borrow(cpre_emphasis_short_decay_allocs)

	var cpre_emphasis_long_level_allocs *cgoAllocMap
	refa8884da4.pre_emphasis_long_level, cpre_emphasis_long_level_allocs = (C.u08)(x.Pre_emphasis_long_level), cgoAllocsUnknown
	allocsa8884da4.Borrow(cpre_emphasis_long_level_allocs)

	var cpre_emphasis_long_decay_allocs *cgoAllocMap
	refa8884da4.pre_emphasis_long_decay, cpre_emphasis_long_decay_allocs = (C.u08)(x.Pre_emphasis_long_decay), cgoAllocsUnknown
	allocsa8884da4.Borrow(cpre_emphasis_long_decay_allocs)

	var coutput_level_allocs *cgoAllocMap
	refa8884da4.output_level, coutput_level_allocs = (C.u08)(x.Output_level), cgoAllocsUnknown
	allocsa8884da4.Borrow(coutput_level_allocs)

	x.refa8884da4 = refa8884da4
	x.allocsa8884da4 = allocsa8884da4
	return refa8884da4, allocsa8884da4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3Channel) PassValue() (C.BeagleUsb3Channel, *cgoAllocMap) {
	if x.refa8884da4 != nil {
		return *x.refa8884da4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3Channel) Deref() {
	if x.refa8884da4 == nil {
		return
	}
	x.Input_equalization_short = (byte)(x.refa8884da4.input_equalization_short)
	x.Input_equalization_medium = (byte)(x.refa8884da4.input_equalization_medium)
	x.Input_equalization_long = (byte)(x.refa8884da4.input_equalization_long)
	x.Pre_emphasis_short_level = (byte)(x.refa8884da4.pre_emphasis_short_level)
	x.Pre_emphasis_short_decay = (byte)(x.refa8884da4.pre_emphasis_short_decay)
	x.Pre_emphasis_long_level = (byte)(x.refa8884da4.pre_emphasis_long_level)
	x.Pre_emphasis_long_decay = (byte)(x.refa8884da4.pre_emphasis_long_decay)
	x.Output_level = (byte)(x.refa8884da4.output_level)
}

// allocBeagleUsb3DataPropertiesMemory allocates memory for type C.BeagleUsb3DataProperties in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3DataPropertiesMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3DataPropertiesValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3DataPropertiesValue = unsafe.Sizeof([1]C.BeagleUsb3DataProperties{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3DataProperties) Ref() *C.BeagleUsb3DataProperties {
	if x == nil {
		return nil
	}
	return x.ref4962ab7
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3DataProperties) Free() {
	if x != nil && x.allocs4962ab7 != nil {
		x.allocs4962ab7.(*cgoAllocMap).Free()
		x.ref4962ab7 = nil
	}
}

// NewBeagleUsb3DataPropertiesRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3DataPropertiesRef(ref unsafe.Pointer) *BeagleUsb3DataProperties {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3DataProperties)
	obj.ref4962ab7 = (*C.BeagleUsb3DataProperties)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3DataProperties) PassRef() (*C.BeagleUsb3DataProperties, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4962ab7 != nil {
		return x.ref4962ab7, nil
	}
	mem4962ab7 := allocBeagleUsb3DataPropertiesMemory(1)
	ref4962ab7 := (*C.BeagleUsb3DataProperties)(mem4962ab7)
	allocs4962ab7 := new(cgoAllocMap)
	allocs4962ab7.Add(mem4962ab7)

	var csource_match_type_allocs *cgoAllocMap
	ref4962ab7.source_match_type, csource_match_type_allocs = (C.BeagleUsbMatchType)(x.Source_match_type), cgoAllocsUnknown
	allocs4962ab7.Borrow(csource_match_type_allocs)

	var csource_match_val_allocs *cgoAllocMap
	ref4962ab7.source_match_val, csource_match_val_allocs = (C.BeagleUsbSource)(x.Source_match_val), cgoAllocsUnknown
	allocs4962ab7.Borrow(csource_match_val_allocs)

	var cep_match_type_allocs *cgoAllocMap
	ref4962ab7.ep_match_type, cep_match_type_allocs = (C.BeagleUsbMatchType)(x.Ep_match_type), cgoAllocsUnknown
	allocs4962ab7.Borrow(cep_match_type_allocs)

	var cep_match_val_allocs *cgoAllocMap
	ref4962ab7.ep_match_val, cep_match_val_allocs = (C.u08)(x.Ep_match_val), cgoAllocsUnknown
	allocs4962ab7.Borrow(cep_match_val_allocs)

	var cdev_match_type_allocs *cgoAllocMap
	ref4962ab7.dev_match_type, cdev_match_type_allocs = (C.BeagleUsbMatchType)(x.Dev_match_type), cgoAllocsUnknown
	allocs4962ab7.Borrow(cdev_match_type_allocs)

	var cdev_match_val_allocs *cgoAllocMap
	ref4962ab7.dev_match_val, cdev_match_val_allocs = (C.u08)(x.Dev_match_val), cgoAllocsUnknown
	allocs4962ab7.Borrow(cdev_match_val_allocs)

	var cstream_id_match_type_allocs *cgoAllocMap
	ref4962ab7.stream_id_match_type, cstream_id_match_type_allocs = (C.BeagleUsbMatchType)(x.Stream_id_match_type), cgoAllocsUnknown
	allocs4962ab7.Borrow(cstream_id_match_type_allocs)

	var cstream_id_match_val_allocs *cgoAllocMap
	ref4962ab7.stream_id_match_val, cstream_id_match_val_allocs = (C.u16)(x.Stream_id_match_val), cgoAllocsUnknown
	allocs4962ab7.Borrow(cstream_id_match_val_allocs)

	var cdata_len_match_type_allocs *cgoAllocMap
	ref4962ab7.data_len_match_type, cdata_len_match_type_allocs = (C.BeagleUsbMatchType)(x.Data_len_match_type), cgoAllocsUnknown
	allocs4962ab7.Borrow(cdata_len_match_type_allocs)

	var cdata_len_match_val_allocs *cgoAllocMap
	ref4962ab7.data_len_match_val, cdata_len_match_val_allocs = (C.u16)(x.Data_len_match_val), cgoAllocsUnknown
	allocs4962ab7.Borrow(cdata_len_match_val_allocs)

	x.ref4962ab7 = ref4962ab7
	x.allocs4962ab7 = allocs4962ab7
	return ref4962ab7, allocs4962ab7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3DataProperties) PassValue() (C.BeagleUsb3DataProperties, *cgoAllocMap) {
	if x.ref4962ab7 != nil {
		return *x.ref4962ab7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3DataProperties) Deref() {
	if x.ref4962ab7 == nil {
		return
	}
	x.Source_match_type = (BeagleUsbMatchType)(x.ref4962ab7.source_match_type)
	x.Source_match_val = (BeagleUsbSource)(x.ref4962ab7.source_match_val)
	x.Ep_match_type = (BeagleUsbMatchType)(x.ref4962ab7.ep_match_type)
	x.Ep_match_val = (byte)(x.ref4962ab7.ep_match_val)
	x.Dev_match_type = (BeagleUsbMatchType)(x.ref4962ab7.dev_match_type)
	x.Dev_match_val = (byte)(x.ref4962ab7.dev_match_val)
	x.Stream_id_match_type = (BeagleUsbMatchType)(x.ref4962ab7.stream_id_match_type)
	x.Stream_id_match_val = (uint16)(x.ref4962ab7.stream_id_match_val)
	x.Data_len_match_type = (BeagleUsbMatchType)(x.ref4962ab7.data_len_match_type)
	x.Data_len_match_val = (uint16)(x.ref4962ab7.data_len_match_val)
}

// allocBeagleUsb3DataMatchUnitMemory allocates memory for type C.BeagleUsb3DataMatchUnit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3DataMatchUnitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3DataMatchUnitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3DataMatchUnitValue = unsafe.Sizeof([1]C.BeagleUsb3DataMatchUnit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3DataMatchUnit) Ref() *C.BeagleUsb3DataMatchUnit {
	if x == nil {
		return nil
	}
	return x.refb332ac5e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3DataMatchUnit) Free() {
	if x != nil && x.allocsb332ac5e != nil {
		x.allocsb332ac5e.(*cgoAllocMap).Free()
		x.refb332ac5e = nil
	}
}

// NewBeagleUsb3DataMatchUnitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3DataMatchUnitRef(ref unsafe.Pointer) *BeagleUsb3DataMatchUnit {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3DataMatchUnit)
	obj.refb332ac5e = (*C.BeagleUsb3DataMatchUnit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3DataMatchUnit) PassRef() (*C.BeagleUsb3DataMatchUnit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb332ac5e != nil {
		return x.refb332ac5e, nil
	}
	memb332ac5e := allocBeagleUsb3DataMatchUnitMemory(1)
	refb332ac5e := (*C.BeagleUsb3DataMatchUnit)(memb332ac5e)
	allocsb332ac5e := new(cgoAllocMap)
	allocsb332ac5e.Add(memb332ac5e)

	var cpacket_type_allocs *cgoAllocMap
	refb332ac5e.packet_type, cpacket_type_allocs = (C.BeagleUsb3PacketType)(x.Packet_type), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cpacket_type_allocs)

	var cdata_length_allocs *cgoAllocMap
	refb332ac5e.data_length, cdata_length_allocs = (C.u16)(x.Data_length), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cdata_length_allocs)

	var cdata_allocs *cgoAllocMap
	refb332ac5e.data, cdata_allocs = *(**C.u08)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cdata_allocs)

	var cdata_valid_length_allocs *cgoAllocMap
	refb332ac5e.data_valid_length, cdata_valid_length_allocs = (C.u16)(x.Data_valid_length), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cdata_valid_length_allocs)

	var cdata_valid_allocs *cgoAllocMap
	refb332ac5e.data_valid, cdata_valid_allocs = *(**C.u08)(unsafe.Pointer(&x.Data_valid)), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cdata_valid_allocs)

	var cerr_match_allocs *cgoAllocMap
	refb332ac5e.err_match, cerr_match_allocs = (C.BeagleUsb3ErrorType)(x.Err_match), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cerr_match_allocs)

	var cdata_properties_valid_allocs *cgoAllocMap
	refb332ac5e.data_properties_valid, cdata_properties_valid_allocs = (C.u08)(x.Data_properties_valid), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cdata_properties_valid_allocs)

	var cdata_properties_allocs *cgoAllocMap
	refb332ac5e.data_properties, cdata_properties_allocs = x.Data_properties.PassValue()
	allocsb332ac5e.Borrow(cdata_properties_allocs)

	var cmatch_modifier_allocs *cgoAllocMap
	refb332ac5e.match_modifier, cmatch_modifier_allocs = (C.BeagleUsb3MatchModifier)(x.Match_modifier), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cmatch_modifier_allocs)

	var crepeat_count_allocs *cgoAllocMap
	refb332ac5e.repeat_count, crepeat_count_allocs = (C.u16)(x.Repeat_count), cgoAllocsUnknown
	allocsb332ac5e.Borrow(crepeat_count_allocs)

	var csticky_action_allocs *cgoAllocMap
	refb332ac5e.sticky_action, csticky_action_allocs = (C.u08)(x.Sticky_action), cgoAllocsUnknown
	allocsb332ac5e.Borrow(csticky_action_allocs)

	var caction_mask_allocs *cgoAllocMap
	refb332ac5e.action_mask, caction_mask_allocs = (C.u08)(x.Action_mask), cgoAllocsUnknown
	allocsb332ac5e.Borrow(caction_mask_allocs)

	var cgoto_selector_allocs *cgoAllocMap
	refb332ac5e.goto_selector, cgoto_selector_allocs = (C.u08)(x.Goto_selector), cgoAllocsUnknown
	allocsb332ac5e.Borrow(cgoto_selector_allocs)

	x.refb332ac5e = refb332ac5e
	x.allocsb332ac5e = allocsb332ac5e
	return refb332ac5e, allocsb332ac5e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3DataMatchUnit) PassValue() (C.BeagleUsb3DataMatchUnit, *cgoAllocMap) {
	if x.refb332ac5e != nil {
		return *x.refb332ac5e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3DataMatchUnit) Deref() {
	if x.refb332ac5e == nil {
		return
	}
	x.Packet_type = (BeagleUsb3PacketType)(x.refb332ac5e.packet_type)
	x.Data_length = (uint16)(x.refb332ac5e.data_length)
	x.Data = (*byte)(unsafe.Pointer(x.refb332ac5e.data))
	x.Data_valid_length = (uint16)(x.refb332ac5e.data_valid_length)
	x.Data_valid = (*byte)(unsafe.Pointer(x.refb332ac5e.data_valid))
	x.Err_match = (BeagleUsb3ErrorType)(x.refb332ac5e.err_match)
	x.Data_properties_valid = (byte)(x.refb332ac5e.data_properties_valid)
	x.Data_properties = *NewBeagleUsb3DataPropertiesRef(unsafe.Pointer(&x.refb332ac5e.data_properties))
	x.Match_modifier = (BeagleUsb3MatchModifier)(x.refb332ac5e.match_modifier)
	x.Repeat_count = (uint16)(x.refb332ac5e.repeat_count)
	x.Sticky_action = (byte)(x.refb332ac5e.sticky_action)
	x.Action_mask = (byte)(x.refb332ac5e.action_mask)
	x.Goto_selector = (byte)(x.refb332ac5e.goto_selector)
}

// allocBeagleUsb3TimerMatchUnitMemory allocates memory for type C.BeagleUsb3TimerMatchUnit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3TimerMatchUnitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3TimerMatchUnitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3TimerMatchUnitValue = unsafe.Sizeof([1]C.BeagleUsb3TimerMatchUnit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3TimerMatchUnit) Ref() *C.BeagleUsb3TimerMatchUnit {
	if x == nil {
		return nil
	}
	return x.ref91b3e3d9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3TimerMatchUnit) Free() {
	if x != nil && x.allocs91b3e3d9 != nil {
		x.allocs91b3e3d9.(*cgoAllocMap).Free()
		x.ref91b3e3d9 = nil
	}
}

// NewBeagleUsb3TimerMatchUnitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3TimerMatchUnitRef(ref unsafe.Pointer) *BeagleUsb3TimerMatchUnit {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3TimerMatchUnit)
	obj.ref91b3e3d9 = (*C.BeagleUsb3TimerMatchUnit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3TimerMatchUnit) PassRef() (*C.BeagleUsb3TimerMatchUnit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref91b3e3d9 != nil {
		return x.ref91b3e3d9, nil
	}
	mem91b3e3d9 := allocBeagleUsb3TimerMatchUnitMemory(1)
	ref91b3e3d9 := (*C.BeagleUsb3TimerMatchUnit)(mem91b3e3d9)
	allocs91b3e3d9 := new(cgoAllocMap)
	allocs91b3e3d9.Add(mem91b3e3d9)

	var ctimer_unit_allocs *cgoAllocMap
	ref91b3e3d9.timer_unit, ctimer_unit_allocs = (C.BeagleUsbTimerUnit)(x.Timer_unit), cgoAllocsUnknown
	allocs91b3e3d9.Borrow(ctimer_unit_allocs)

	var ctimer_val_allocs *cgoAllocMap
	ref91b3e3d9.timer_val, ctimer_val_allocs = (C.u32)(x.Timer_val), cgoAllocsUnknown
	allocs91b3e3d9.Borrow(ctimer_val_allocs)

	var caction_mask_allocs *cgoAllocMap
	ref91b3e3d9.action_mask, caction_mask_allocs = (C.u08)(x.Action_mask), cgoAllocsUnknown
	allocs91b3e3d9.Borrow(caction_mask_allocs)

	var cgoto_selector_allocs *cgoAllocMap
	ref91b3e3d9.goto_selector, cgoto_selector_allocs = (C.u08)(x.Goto_selector), cgoAllocsUnknown
	allocs91b3e3d9.Borrow(cgoto_selector_allocs)

	x.ref91b3e3d9 = ref91b3e3d9
	x.allocs91b3e3d9 = allocs91b3e3d9
	return ref91b3e3d9, allocs91b3e3d9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3TimerMatchUnit) PassValue() (C.BeagleUsb3TimerMatchUnit, *cgoAllocMap) {
	if x.ref91b3e3d9 != nil {
		return *x.ref91b3e3d9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3TimerMatchUnit) Deref() {
	if x.ref91b3e3d9 == nil {
		return
	}
	x.Timer_unit = (BeagleUsbTimerUnit)(x.ref91b3e3d9.timer_unit)
	x.Timer_val = (uint32)(x.ref91b3e3d9.timer_val)
	x.Action_mask = (byte)(x.ref91b3e3d9.action_mask)
	x.Goto_selector = (byte)(x.ref91b3e3d9.goto_selector)
}

// allocBeagleUsb3AsyncEventMatchUnitMemory allocates memory for type C.BeagleUsb3AsyncEventMatchUnit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3AsyncEventMatchUnitMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3AsyncEventMatchUnitValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3AsyncEventMatchUnitValue = unsafe.Sizeof([1]C.BeagleUsb3AsyncEventMatchUnit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3AsyncEventMatchUnit) Ref() *C.BeagleUsb3AsyncEventMatchUnit {
	if x == nil {
		return nil
	}
	return x.ref42414f2d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3AsyncEventMatchUnit) Free() {
	if x != nil && x.allocs42414f2d != nil {
		x.allocs42414f2d.(*cgoAllocMap).Free()
		x.ref42414f2d = nil
	}
}

// NewBeagleUsb3AsyncEventMatchUnitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3AsyncEventMatchUnitRef(ref unsafe.Pointer) *BeagleUsb3AsyncEventMatchUnit {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3AsyncEventMatchUnit)
	obj.ref42414f2d = (*C.BeagleUsb3AsyncEventMatchUnit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3AsyncEventMatchUnit) PassRef() (*C.BeagleUsb3AsyncEventMatchUnit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42414f2d != nil {
		return x.ref42414f2d, nil
	}
	mem42414f2d := allocBeagleUsb3AsyncEventMatchUnitMemory(1)
	ref42414f2d := (*C.BeagleUsb3AsyncEventMatchUnit)(mem42414f2d)
	allocs42414f2d := new(cgoAllocMap)
	allocs42414f2d.Add(mem42414f2d)

	var cevent_type_allocs *cgoAllocMap
	ref42414f2d.event_type, cevent_type_allocs = (C.BeagleUsb3AsyncEventType)(x.Event_type), cgoAllocsUnknown
	allocs42414f2d.Borrow(cevent_type_allocs)

	var cedge_mask_allocs *cgoAllocMap
	ref42414f2d.edge_mask, cedge_mask_allocs = (C.u08)(x.Edge_mask), cgoAllocsUnknown
	allocs42414f2d.Borrow(cedge_mask_allocs)

	var crepeat_count_allocs *cgoAllocMap
	ref42414f2d.repeat_count, crepeat_count_allocs = (C.u16)(x.Repeat_count), cgoAllocsUnknown
	allocs42414f2d.Borrow(crepeat_count_allocs)

	var csticky_action_allocs *cgoAllocMap
	ref42414f2d.sticky_action, csticky_action_allocs = (C.u08)(x.Sticky_action), cgoAllocsUnknown
	allocs42414f2d.Borrow(csticky_action_allocs)

	var caction_mask_allocs *cgoAllocMap
	ref42414f2d.action_mask, caction_mask_allocs = (C.u08)(x.Action_mask), cgoAllocsUnknown
	allocs42414f2d.Borrow(caction_mask_allocs)

	var cgoto_selector_allocs *cgoAllocMap
	ref42414f2d.goto_selector, cgoto_selector_allocs = (C.u08)(x.Goto_selector), cgoAllocsUnknown
	allocs42414f2d.Borrow(cgoto_selector_allocs)

	x.ref42414f2d = ref42414f2d
	x.allocs42414f2d = allocs42414f2d
	return ref42414f2d, allocs42414f2d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3AsyncEventMatchUnit) PassValue() (C.BeagleUsb3AsyncEventMatchUnit, *cgoAllocMap) {
	if x.ref42414f2d != nil {
		return *x.ref42414f2d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3AsyncEventMatchUnit) Deref() {
	if x.ref42414f2d == nil {
		return
	}
	x.Event_type = (BeagleUsb3AsyncEventType)(x.ref42414f2d.event_type)
	x.Edge_mask = (byte)(x.ref42414f2d.edge_mask)
	x.Repeat_count = (uint16)(x.ref42414f2d.repeat_count)
	x.Sticky_action = (byte)(x.ref42414f2d.sticky_action)
	x.Action_mask = (byte)(x.ref42414f2d.action_mask)
	x.Goto_selector = (byte)(x.ref42414f2d.goto_selector)
}

// allocBeagleUsb3ComplexMatchStateMemory allocates memory for type C.BeagleUsb3ComplexMatchState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3ComplexMatchStateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3ComplexMatchStateValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3ComplexMatchStateValue = unsafe.Sizeof([1]C.BeagleUsb3ComplexMatchState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3ComplexMatchState) Ref() *C.BeagleUsb3ComplexMatchState {
	if x == nil {
		return nil
	}
	return x.ref1e748a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3ComplexMatchState) Free() {
	if x != nil && x.allocs1e748a4 != nil {
		x.allocs1e748a4.(*cgoAllocMap).Free()
		x.ref1e748a4 = nil
	}
}

// NewBeagleUsb3ComplexMatchStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3ComplexMatchStateRef(ref unsafe.Pointer) *BeagleUsb3ComplexMatchState {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3ComplexMatchState)
	obj.ref1e748a4 = (*C.BeagleUsb3ComplexMatchState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3ComplexMatchState) PassRef() (*C.BeagleUsb3ComplexMatchState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1e748a4 != nil {
		return x.ref1e748a4, nil
	}
	mem1e748a4 := allocBeagleUsb3ComplexMatchStateMemory(1)
	ref1e748a4 := (*C.BeagleUsb3ComplexMatchState)(mem1e748a4)
	allocs1e748a4 := new(cgoAllocMap)
	allocs1e748a4.Add(mem1e748a4)

	var ctx_data_0_valid_allocs *cgoAllocMap
	ref1e748a4.tx_data_0_valid, ctx_data_0_valid_allocs = (C.u08)(x.Tx_data_0_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(ctx_data_0_valid_allocs)

	var ctx_data_0_match_allocs *cgoAllocMap
	ref1e748a4.tx_data_0_match, ctx_data_0_match_allocs = x.Tx_data_0_match.PassValue()
	allocs1e748a4.Borrow(ctx_data_0_match_allocs)

	var ctx_data_1_valid_allocs *cgoAllocMap
	ref1e748a4.tx_data_1_valid, ctx_data_1_valid_allocs = (C.u08)(x.Tx_data_1_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(ctx_data_1_valid_allocs)

	var ctx_data_1_match_allocs *cgoAllocMap
	ref1e748a4.tx_data_1_match, ctx_data_1_match_allocs = x.Tx_data_1_match.PassValue()
	allocs1e748a4.Borrow(ctx_data_1_match_allocs)

	var ctx_data_2_valid_allocs *cgoAllocMap
	ref1e748a4.tx_data_2_valid, ctx_data_2_valid_allocs = (C.u08)(x.Tx_data_2_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(ctx_data_2_valid_allocs)

	var ctx_data_2_match_allocs *cgoAllocMap
	ref1e748a4.tx_data_2_match, ctx_data_2_match_allocs = x.Tx_data_2_match.PassValue()
	allocs1e748a4.Borrow(ctx_data_2_match_allocs)

	var crx_data_0_valid_allocs *cgoAllocMap
	ref1e748a4.rx_data_0_valid, crx_data_0_valid_allocs = (C.u08)(x.Rx_data_0_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(crx_data_0_valid_allocs)

	var crx_data_0_match_allocs *cgoAllocMap
	ref1e748a4.rx_data_0_match, crx_data_0_match_allocs = x.Rx_data_0_match.PassValue()
	allocs1e748a4.Borrow(crx_data_0_match_allocs)

	var crx_data_1_valid_allocs *cgoAllocMap
	ref1e748a4.rx_data_1_valid, crx_data_1_valid_allocs = (C.u08)(x.Rx_data_1_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(crx_data_1_valid_allocs)

	var crx_data_1_match_allocs *cgoAllocMap
	ref1e748a4.rx_data_1_match, crx_data_1_match_allocs = x.Rx_data_1_match.PassValue()
	allocs1e748a4.Borrow(crx_data_1_match_allocs)

	var crx_data_2_valid_allocs *cgoAllocMap
	ref1e748a4.rx_data_2_valid, crx_data_2_valid_allocs = (C.u08)(x.Rx_data_2_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(crx_data_2_valid_allocs)

	var crx_data_2_match_allocs *cgoAllocMap
	ref1e748a4.rx_data_2_match, crx_data_2_match_allocs = x.Rx_data_2_match.PassValue()
	allocs1e748a4.Borrow(crx_data_2_match_allocs)

	var ctimer_valid_allocs *cgoAllocMap
	ref1e748a4.timer_valid, ctimer_valid_allocs = (C.u08)(x.Timer_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(ctimer_valid_allocs)

	var ctimer_match_allocs *cgoAllocMap
	ref1e748a4.timer_match, ctimer_match_allocs = x.Timer_match.PassValue()
	allocs1e748a4.Borrow(ctimer_match_allocs)

	var casync_valid_allocs *cgoAllocMap
	ref1e748a4.async_valid, casync_valid_allocs = (C.u08)(x.Async_valid), cgoAllocsUnknown
	allocs1e748a4.Borrow(casync_valid_allocs)

	var casync_match_allocs *cgoAllocMap
	ref1e748a4.async_match, casync_match_allocs = x.Async_match.PassValue()
	allocs1e748a4.Borrow(casync_match_allocs)

	var cgoto_0_allocs *cgoAllocMap
	ref1e748a4.goto_0, cgoto_0_allocs = (C.u08)(x.Goto_0), cgoAllocsUnknown
	allocs1e748a4.Borrow(cgoto_0_allocs)

	var cgoto_1_allocs *cgoAllocMap
	ref1e748a4.goto_1, cgoto_1_allocs = (C.u08)(x.Goto_1), cgoAllocsUnknown
	allocs1e748a4.Borrow(cgoto_1_allocs)

	var cgoto_2_allocs *cgoAllocMap
	ref1e748a4.goto_2, cgoto_2_allocs = (C.u08)(x.Goto_2), cgoAllocsUnknown
	allocs1e748a4.Borrow(cgoto_2_allocs)

	x.ref1e748a4 = ref1e748a4
	x.allocs1e748a4 = allocs1e748a4
	return ref1e748a4, allocs1e748a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3ComplexMatchState) PassValue() (C.BeagleUsb3ComplexMatchState, *cgoAllocMap) {
	if x.ref1e748a4 != nil {
		return *x.ref1e748a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3ComplexMatchState) Deref() {
	if x.ref1e748a4 == nil {
		return
	}
	x.Tx_data_0_valid = (byte)(x.ref1e748a4.tx_data_0_valid)
	x.Tx_data_0_match = *NewBeagleUsb3DataMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.tx_data_0_match))
	x.Tx_data_1_valid = (byte)(x.ref1e748a4.tx_data_1_valid)
	x.Tx_data_1_match = *NewBeagleUsb3DataMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.tx_data_1_match))
	x.Tx_data_2_valid = (byte)(x.ref1e748a4.tx_data_2_valid)
	x.Tx_data_2_match = *NewBeagleUsb3DataMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.tx_data_2_match))
	x.Rx_data_0_valid = (byte)(x.ref1e748a4.rx_data_0_valid)
	x.Rx_data_0_match = *NewBeagleUsb3DataMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.rx_data_0_match))
	x.Rx_data_1_valid = (byte)(x.ref1e748a4.rx_data_1_valid)
	x.Rx_data_1_match = *NewBeagleUsb3DataMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.rx_data_1_match))
	x.Rx_data_2_valid = (byte)(x.ref1e748a4.rx_data_2_valid)
	x.Rx_data_2_match = *NewBeagleUsb3DataMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.rx_data_2_match))
	x.Timer_valid = (byte)(x.ref1e748a4.timer_valid)
	x.Timer_match = *NewBeagleUsb3TimerMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.timer_match))
	x.Async_valid = (byte)(x.ref1e748a4.async_valid)
	x.Async_match = *NewBeagleUsb3AsyncEventMatchUnitRef(unsafe.Pointer(&x.ref1e748a4.async_match))
	x.Goto_0 = (byte)(x.ref1e748a4.goto_0)
	x.Goto_1 = (byte)(x.ref1e748a4.goto_1)
	x.Goto_2 = (byte)(x.ref1e748a4.goto_2)
}

// allocBeagleUsbStatsConfigMemory allocates memory for type C.BeagleUsbStatsConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsbStatsConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsbStatsConfigValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsbStatsConfigValue = unsafe.Sizeof([1]C.BeagleUsbStatsConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsbStatsConfig) Ref() *C.BeagleUsbStatsConfig {
	if x == nil {
		return nil
	}
	return x.refb3b6387a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsbStatsConfig) Free() {
	if x != nil && x.allocsb3b6387a != nil {
		x.allocsb3b6387a.(*cgoAllocMap).Free()
		x.refb3b6387a = nil
	}
}

// NewBeagleUsbStatsConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsbStatsConfigRef(ref unsafe.Pointer) *BeagleUsbStatsConfig {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsbStatsConfig)
	obj.refb3b6387a = (*C.BeagleUsbStatsConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsbStatsConfig) PassRef() (*C.BeagleUsbStatsConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb3b6387a != nil {
		return x.refb3b6387a, nil
	}
	memb3b6387a := allocBeagleUsbStatsConfigMemory(1)
	refb3b6387a := (*C.BeagleUsbStatsConfig)(memb3b6387a)
	allocsb3b6387a := new(cgoAllocMap)
	allocsb3b6387a.Add(memb3b6387a)

	var cauto_config_allocs *cgoAllocMap
	refb3b6387a.auto_config, cauto_config_allocs = (C.u08)(x.Auto_config), cgoAllocsUnknown
	allocsb3b6387a.Borrow(cauto_config_allocs)

	var csource_match_type_allocs *cgoAllocMap
	refb3b6387a.source_match_type, csource_match_type_allocs = (C.BeagleUsbMatchType)(x.Source_match_type), cgoAllocsUnknown
	allocsb3b6387a.Borrow(csource_match_type_allocs)

	var csource_match_val_allocs *cgoAllocMap
	refb3b6387a.source_match_val, csource_match_val_allocs = (C.BeagleUsbSource)(x.Source_match_val), cgoAllocsUnknown
	allocsb3b6387a.Borrow(csource_match_val_allocs)

	var cep_match_type_allocs *cgoAllocMap
	refb3b6387a.ep_match_type, cep_match_type_allocs = (C.BeagleUsbMatchType)(x.Ep_match_type), cgoAllocsUnknown
	allocsb3b6387a.Borrow(cep_match_type_allocs)

	var cep_match_val_allocs *cgoAllocMap
	refb3b6387a.ep_match_val, cep_match_val_allocs = (C.u08)(x.Ep_match_val), cgoAllocsUnknown
	allocsb3b6387a.Borrow(cep_match_val_allocs)

	var cdev_match_type_allocs *cgoAllocMap
	refb3b6387a.dev_match_type, cdev_match_type_allocs = (C.BeagleUsbMatchType)(x.Dev_match_type), cgoAllocsUnknown
	allocsb3b6387a.Borrow(cdev_match_type_allocs)

	var cdev_match_val_allocs *cgoAllocMap
	refb3b6387a.dev_match_val, cdev_match_val_allocs = (C.u08)(x.Dev_match_val), cgoAllocsUnknown
	allocsb3b6387a.Borrow(cdev_match_val_allocs)

	x.refb3b6387a = refb3b6387a
	x.allocsb3b6387a = allocsb3b6387a
	return refb3b6387a, allocsb3b6387a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsbStatsConfig) PassValue() (C.BeagleUsbStatsConfig, *cgoAllocMap) {
	if x.refb3b6387a != nil {
		return *x.refb3b6387a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsbStatsConfig) Deref() {
	if x.refb3b6387a == nil {
		return
	}
	x.Auto_config = (byte)(x.refb3b6387a.auto_config)
	x.Source_match_type = (BeagleUsbMatchType)(x.refb3b6387a.source_match_type)
	x.Source_match_val = (BeagleUsbSource)(x.refb3b6387a.source_match_val)
	x.Ep_match_type = (BeagleUsbMatchType)(x.refb3b6387a.ep_match_type)
	x.Ep_match_val = (byte)(x.refb3b6387a.ep_match_val)
	x.Dev_match_type = (BeagleUsbMatchType)(x.refb3b6387a.dev_match_type)
	x.Dev_match_val = (byte)(x.refb3b6387a.dev_match_val)
}

// allocBeagleUsb3GenStatsMemory allocates memory for type C.BeagleUsb3GenStats in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3GenStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3GenStatsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3GenStatsValue = unsafe.Sizeof([1]C.BeagleUsb3GenStats{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3GenStats) Ref() *C.BeagleUsb3GenStats {
	if x == nil {
		return nil
	}
	return x.ref3dd10611
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3GenStats) Free() {
	if x != nil && x.allocs3dd10611 != nil {
		x.allocs3dd10611.(*cgoAllocMap).Free()
		x.ref3dd10611 = nil
	}
}

// NewBeagleUsb3GenStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3GenStatsRef(ref unsafe.Pointer) *BeagleUsb3GenStats {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3GenStats)
	obj.ref3dd10611 = (*C.BeagleUsb3GenStats)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3GenStats) PassRef() (*C.BeagleUsb3GenStats, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3dd10611 != nil {
		return x.ref3dd10611, nil
	}
	mem3dd10611 := allocBeagleUsb3GenStatsMemory(1)
	ref3dd10611 := (*C.BeagleUsb3GenStats)(mem3dd10611)
	allocs3dd10611 := new(cgoAllocMap)
	allocs3dd10611.Add(mem3dd10611)

	var clink_allocs *cgoAllocMap
	ref3dd10611.link, clink_allocs = (C.u64)(x.Link), cgoAllocsUnknown
	allocs3dd10611.Borrow(clink_allocs)

	var clbad_allocs *cgoAllocMap
	ref3dd10611.lbad, clbad_allocs = (C.u64)(x.Lbad), cgoAllocsUnknown
	allocs3dd10611.Borrow(clbad_allocs)

	var cslc_crc5_allocs *cgoAllocMap
	ref3dd10611.slc_crc5, cslc_crc5_allocs = (C.u64)(x.Slc_crc5), cgoAllocsUnknown
	allocs3dd10611.Borrow(cslc_crc5_allocs)

	var ctxn_allocs *cgoAllocMap
	ref3dd10611.txn, ctxn_allocs = (C.u64)(x.Txn), cgoAllocsUnknown
	allocs3dd10611.Borrow(ctxn_allocs)

	var clmp_allocs *cgoAllocMap
	ref3dd10611.lmp, clmp_allocs = (C.u64)(x.Lmp), cgoAllocsUnknown
	allocs3dd10611.Borrow(clmp_allocs)

	var clgo_u1_allocs *cgoAllocMap
	ref3dd10611.lgo_u1, clgo_u1_allocs = (C.u64)(x.Lgo_u1), cgoAllocsUnknown
	allocs3dd10611.Borrow(clgo_u1_allocs)

	var clgo_u2_allocs *cgoAllocMap
	ref3dd10611.lgo_u2, clgo_u2_allocs = (C.u64)(x.Lgo_u2), cgoAllocsUnknown
	allocs3dd10611.Borrow(clgo_u2_allocs)

	var clgo_u3_allocs *cgoAllocMap
	ref3dd10611.lgo_u3, clgo_u3_allocs = (C.u64)(x.Lgo_u3), cgoAllocsUnknown
	allocs3dd10611.Borrow(clgo_u3_allocs)

	var cdp_allocs *cgoAllocMap
	ref3dd10611.dp, cdp_allocs = (C.u64)(x.Dp), cgoAllocsUnknown
	allocs3dd10611.Borrow(cdp_allocs)

	var citp_allocs *cgoAllocMap
	ref3dd10611.itp, citp_allocs = (C.u64)(x.Itp), cgoAllocsUnknown
	allocs3dd10611.Borrow(citp_allocs)

	var cshp_crc16_crc5_allocs *cgoAllocMap
	ref3dd10611.shp_crc16_crc5, cshp_crc16_crc5_allocs = (C.u64)(x.Shp_crc16_crc5), cgoAllocsUnknown
	allocs3dd10611.Borrow(cshp_crc16_crc5_allocs)

	var csdp_crc32_allocs *cgoAllocMap
	ref3dd10611.sdp_crc32, csdp_crc32_allocs = (C.u64)(x.Sdp_crc32), cgoAllocsUnknown
	allocs3dd10611.Borrow(csdp_crc32_allocs)

	var cslc_frm_err_allocs *cgoAllocMap
	ref3dd10611.slc_frm_err, cslc_frm_err_allocs = (C.u64)(x.Slc_frm_err), cgoAllocsUnknown
	allocs3dd10611.Borrow(cslc_frm_err_allocs)

	var cshp_frm_err_allocs *cgoAllocMap
	ref3dd10611.shp_frm_err, cshp_frm_err_allocs = (C.u64)(x.Shp_frm_err), cgoAllocsUnknown
	allocs3dd10611.Borrow(cshp_frm_err_allocs)

	var csdp_end_edb_frm_err_allocs *cgoAllocMap
	ref3dd10611.sdp_end_edb_frm_err, csdp_end_edb_frm_err_allocs = (C.u64)(x.Sdp_end_edb_frm_err), cgoAllocsUnknown
	allocs3dd10611.Borrow(csdp_end_edb_frm_err_allocs)

	var ciso_ips_allocs *cgoAllocMap
	ref3dd10611.iso_ips, ciso_ips_allocs = (C.u64)(x.Iso_ips), cgoAllocsUnknown
	allocs3dd10611.Borrow(ciso_ips_allocs)

	var cpara_ips_allocs *cgoAllocMap
	ref3dd10611.para_ips, cpara_ips_allocs = (C.u64)(x.Para_ips), cgoAllocsUnknown
	allocs3dd10611.Borrow(cpara_ips_allocs)

	var ccarry_1k_dp_allocs *cgoAllocMap
	ref3dd10611.carry_1k_dp, ccarry_1k_dp_allocs = (C.u64)(x.Carry_1k_dp), cgoAllocsUnknown
	allocs3dd10611.Borrow(ccarry_1k_dp_allocs)

	x.ref3dd10611 = ref3dd10611
	x.allocs3dd10611 = allocs3dd10611
	return ref3dd10611, allocs3dd10611

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3GenStats) PassValue() (C.BeagleUsb3GenStats, *cgoAllocMap) {
	if x.ref3dd10611 != nil {
		return *x.ref3dd10611, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3GenStats) Deref() {
	if x.ref3dd10611 == nil {
		return
	}
	x.Link = (uint64)(x.ref3dd10611.link)
	x.Lbad = (uint64)(x.ref3dd10611.lbad)
	x.Slc_crc5 = (uint64)(x.ref3dd10611.slc_crc5)
	x.Txn = (uint64)(x.ref3dd10611.txn)
	x.Lmp = (uint64)(x.ref3dd10611.lmp)
	x.Lgo_u1 = (uint64)(x.ref3dd10611.lgo_u1)
	x.Lgo_u2 = (uint64)(x.ref3dd10611.lgo_u2)
	x.Lgo_u3 = (uint64)(x.ref3dd10611.lgo_u3)
	x.Dp = (uint64)(x.ref3dd10611.dp)
	x.Itp = (uint64)(x.ref3dd10611.itp)
	x.Shp_crc16_crc5 = (uint64)(x.ref3dd10611.shp_crc16_crc5)
	x.Sdp_crc32 = (uint64)(x.ref3dd10611.sdp_crc32)
	x.Slc_frm_err = (uint64)(x.ref3dd10611.slc_frm_err)
	x.Shp_frm_err = (uint64)(x.ref3dd10611.shp_frm_err)
	x.Sdp_end_edb_frm_err = (uint64)(x.ref3dd10611.sdp_end_edb_frm_err)
	x.Iso_ips = (uint64)(x.ref3dd10611.iso_ips)
	x.Para_ips = (uint64)(x.ref3dd10611.para_ips)
	x.Carry_1k_dp = (uint64)(x.ref3dd10611.carry_1k_dp)
}

// allocBeagleUsb3ConnStatsMemory allocates memory for type C.BeagleUsb3ConnStats in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb3ConnStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb3ConnStatsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb3ConnStatsValue = unsafe.Sizeof([1]C.BeagleUsb3ConnStats{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb3ConnStats) Ref() *C.BeagleUsb3ConnStats {
	if x == nil {
		return nil
	}
	return x.ref44c1c4ad
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb3ConnStats) Free() {
	if x != nil && x.allocs44c1c4ad != nil {
		x.allocs44c1c4ad.(*cgoAllocMap).Free()
		x.ref44c1c4ad = nil
	}
}

// NewBeagleUsb3ConnStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb3ConnStatsRef(ref unsafe.Pointer) *BeagleUsb3ConnStats {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb3ConnStats)
	obj.ref44c1c4ad = (*C.BeagleUsb3ConnStats)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb3ConnStats) PassRef() (*C.BeagleUsb3ConnStats, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref44c1c4ad != nil {
		return x.ref44c1c4ad, nil
	}
	mem44c1c4ad := allocBeagleUsb3ConnStatsMemory(1)
	ref44c1c4ad := (*C.BeagleUsb3ConnStats)(mem44c1c4ad)
	allocs44c1c4ad := new(cgoAllocMap)
	allocs44c1c4ad.Add(mem44c1c4ad)

	var ctxn_allocs *cgoAllocMap
	ref44c1c4ad.txn, ctxn_allocs = (C.u64)(x.Txn), cgoAllocsUnknown
	allocs44c1c4ad.Borrow(ctxn_allocs)

	var cdp_allocs *cgoAllocMap
	ref44c1c4ad.dp, cdp_allocs = (C.u64)(x.Dp), cgoAllocsUnknown
	allocs44c1c4ad.Borrow(cdp_allocs)

	var cack_allocs *cgoAllocMap
	ref44c1c4ad.ack, cack_allocs = (C.u64)(x.Ack), cgoAllocsUnknown
	allocs44c1c4ad.Borrow(cack_allocs)

	var cnrdy_allocs *cgoAllocMap
	ref44c1c4ad.nrdy, cnrdy_allocs = (C.u64)(x.Nrdy), cgoAllocsUnknown
	allocs44c1c4ad.Borrow(cnrdy_allocs)

	var cerdy_allocs *cgoAllocMap
	ref44c1c4ad.erdy, cerdy_allocs = (C.u64)(x.Erdy), cgoAllocsUnknown
	allocs44c1c4ad.Borrow(cerdy_allocs)

	var cretry_ack_allocs *cgoAllocMap
	ref44c1c4ad.retry_ack, cretry_ack_allocs = (C.u64)(x.Retry_ack), cgoAllocsUnknown
	allocs44c1c4ad.Borrow(cretry_ack_allocs)

	var ccarry_1k_dp_allocs *cgoAllocMap
	ref44c1c4ad.carry_1k_dp, ccarry_1k_dp_allocs = (C.u64)(x.Carry_1k_dp), cgoAllocsUnknown
	allocs44c1c4ad.Borrow(ccarry_1k_dp_allocs)

	x.ref44c1c4ad = ref44c1c4ad
	x.allocs44c1c4ad = allocs44c1c4ad
	return ref44c1c4ad, allocs44c1c4ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb3ConnStats) PassValue() (C.BeagleUsb3ConnStats, *cgoAllocMap) {
	if x.ref44c1c4ad != nil {
		return *x.ref44c1c4ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb3ConnStats) Deref() {
	if x.ref44c1c4ad == nil {
		return
	}
	x.Txn = (uint64)(x.ref44c1c4ad.txn)
	x.Dp = (uint64)(x.ref44c1c4ad.dp)
	x.Ack = (uint64)(x.ref44c1c4ad.ack)
	x.Nrdy = (uint64)(x.ref44c1c4ad.nrdy)
	x.Erdy = (uint64)(x.ref44c1c4ad.erdy)
	x.Retry_ack = (uint64)(x.ref44c1c4ad.retry_ack)
	x.Carry_1k_dp = (uint64)(x.ref44c1c4ad.carry_1k_dp)
}

// allocBeagleUsb2StatsMemory allocates memory for type C.BeagleUsb2Stats in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsb2StatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsb2StatsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsb2StatsValue = unsafe.Sizeof([1]C.BeagleUsb2Stats{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsb2Stats) Ref() *C.BeagleUsb2Stats {
	if x == nil {
		return nil
	}
	return x.ref405ab34b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsb2Stats) Free() {
	if x != nil && x.allocs405ab34b != nil {
		x.allocs405ab34b.(*cgoAllocMap).Free()
		x.ref405ab34b = nil
	}
}

// NewBeagleUsb2StatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsb2StatsRef(ref unsafe.Pointer) *BeagleUsb2Stats {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsb2Stats)
	obj.ref405ab34b = (*C.BeagleUsb2Stats)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsb2Stats) PassRef() (*C.BeagleUsb2Stats, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref405ab34b != nil {
		return x.ref405ab34b, nil
	}
	mem405ab34b := allocBeagleUsb2StatsMemory(1)
	ref405ab34b := (*C.BeagleUsb2Stats)(mem405ab34b)
	allocs405ab34b := new(cgoAllocMap)
	allocs405ab34b.Add(mem405ab34b)

	var csof_allocs *cgoAllocMap
	ref405ab34b.sof, csof_allocs = (C.u64)(x.Sof), cgoAllocsUnknown
	allocs405ab34b.Borrow(csof_allocs)

	var ccarry_1k_data_allocs *cgoAllocMap
	ref405ab34b.carry_1k_data, ccarry_1k_data_allocs = (C.u64)(x.Carry_1k_data), cgoAllocsUnknown
	allocs405ab34b.Borrow(ccarry_1k_data_allocs)

	var cdata_allocs *cgoAllocMap
	ref405ab34b.data, cdata_allocs = (C.u64)(x.Data), cgoAllocsUnknown
	allocs405ab34b.Borrow(cdata_allocs)

	var cbad_pid_allocs *cgoAllocMap
	ref405ab34b.bad_pid, cbad_pid_allocs = (C.u64)(x.Bad_pid), cgoAllocsUnknown
	allocs405ab34b.Borrow(cbad_pid_allocs)

	var ccrc16_allocs *cgoAllocMap
	ref405ab34b.crc16, ccrc16_allocs = (C.u64)(x.Crc16), cgoAllocsUnknown
	allocs405ab34b.Borrow(ccrc16_allocs)

	var ccrc5_allocs *cgoAllocMap
	ref405ab34b.crc5, ccrc5_allocs = (C.u64)(x.Crc5), cgoAllocsUnknown
	allocs405ab34b.Borrow(ccrc5_allocs)

	var crx_error_allocs *cgoAllocMap
	ref405ab34b.rx_error, crx_error_allocs = (C.u64)(x.Rx_error), cgoAllocsUnknown
	allocs405ab34b.Borrow(crx_error_allocs)

	var cin_nak_allocs *cgoAllocMap
	ref405ab34b.in_nak, cin_nak_allocs = (C.u64)(x.In_nak), cgoAllocsUnknown
	allocs405ab34b.Borrow(cin_nak_allocs)

	var cping_nak_allocs *cgoAllocMap
	ref405ab34b.ping_nak, cping_nak_allocs = (C.u64)(x.Ping_nak), cgoAllocsUnknown
	allocs405ab34b.Borrow(cping_nak_allocs)

	x.ref405ab34b = ref405ab34b
	x.allocs405ab34b = allocs405ab34b
	return ref405ab34b, allocs405ab34b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsb2Stats) PassValue() (C.BeagleUsb2Stats, *cgoAllocMap) {
	if x.ref405ab34b != nil {
		return *x.ref405ab34b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsb2Stats) Deref() {
	if x.ref405ab34b == nil {
		return
	}
	x.Sof = (uint64)(x.ref405ab34b.sof)
	x.Carry_1k_data = (uint64)(x.ref405ab34b.carry_1k_data)
	x.Data = (uint64)(x.ref405ab34b.data)
	x.Bad_pid = (uint64)(x.ref405ab34b.bad_pid)
	x.Crc16 = (uint64)(x.ref405ab34b.crc16)
	x.Crc5 = (uint64)(x.ref405ab34b.crc5)
	x.Rx_error = (uint64)(x.ref405ab34b.rx_error)
	x.In_nak = (uint64)(x.ref405ab34b.in_nak)
	x.Ping_nak = (uint64)(x.ref405ab34b.ping_nak)
}

// allocBeagleUsbStatsMemory allocates memory for type C.BeagleUsbStats in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleUsbStatsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleUsbStatsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleUsbStatsValue = unsafe.Sizeof([1]C.BeagleUsbStats{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BeagleUsbStats) Ref() *C.BeagleUsbStats {
	if x == nil {
		return nil
	}
	return x.refa05986e9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BeagleUsbStats) Free() {
	if x != nil && x.allocsa05986e9 != nil {
		x.allocsa05986e9.(*cgoAllocMap).Free()
		x.refa05986e9 = nil
	}
}

// NewBeagleUsbStatsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBeagleUsbStatsRef(ref unsafe.Pointer) *BeagleUsbStats {
	if ref == nil {
		return nil
	}
	obj := new(BeagleUsbStats)
	obj.refa05986e9 = (*C.BeagleUsbStats)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BeagleUsbStats) PassRef() (*C.BeagleUsbStats, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa05986e9 != nil {
		return x.refa05986e9, nil
	}
	mema05986e9 := allocBeagleUsbStatsMemory(1)
	refa05986e9 := (*C.BeagleUsbStats)(mema05986e9)
	allocsa05986e9 := new(cgoAllocMap)
	allocsa05986e9.Add(mema05986e9)

	var cusb3_tx_gen_allocs *cgoAllocMap
	refa05986e9.usb3_tx_gen, cusb3_tx_gen_allocs = x.Usb3_tx_gen.PassValue()
	allocsa05986e9.Borrow(cusb3_tx_gen_allocs)

	var cusb3_rx_gen_allocs *cgoAllocMap
	refa05986e9.usb3_rx_gen, cusb3_rx_gen_allocs = x.Usb3_rx_gen.PassValue()
	allocsa05986e9.Borrow(cusb3_rx_gen_allocs)

	var cusb3_tx_conn_allocs *cgoAllocMap
	refa05986e9.usb3_tx_conn, cusb3_tx_conn_allocs = x.Usb3_tx_conn.PassValue()
	allocsa05986e9.Borrow(cusb3_tx_conn_allocs)

	var cusb3_rx_conn_allocs *cgoAllocMap
	refa05986e9.usb3_rx_conn, cusb3_rx_conn_allocs = x.Usb3_rx_conn.PassValue()
	allocsa05986e9.Borrow(cusb3_rx_conn_allocs)

	var cusb2_allocs *cgoAllocMap
	refa05986e9.usb2, cusb2_allocs = x.Usb2.PassValue()
	allocsa05986e9.Borrow(cusb2_allocs)

	x.refa05986e9 = refa05986e9
	x.allocsa05986e9 = allocsa05986e9
	return refa05986e9, allocsa05986e9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BeagleUsbStats) PassValue() (C.BeagleUsbStats, *cgoAllocMap) {
	if x.refa05986e9 != nil {
		return *x.refa05986e9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BeagleUsbStats) Deref() {
	if x.refa05986e9 == nil {
		return
	}
	x.Usb3_tx_gen = *NewBeagleUsb3GenStatsRef(unsafe.Pointer(&x.refa05986e9.usb3_tx_gen))
	x.Usb3_rx_gen = *NewBeagleUsb3GenStatsRef(unsafe.Pointer(&x.refa05986e9.usb3_rx_gen))
	x.Usb3_tx_conn = *NewBeagleUsb3ConnStatsRef(unsafe.Pointer(&x.refa05986e9.usb3_tx_conn))
	x.Usb3_rx_conn = *NewBeagleUsb3ConnStatsRef(unsafe.Pointer(&x.refa05986e9.usb3_rx_conn))
	x.Usb2 = *NewBeagleUsb2StatsRef(unsafe.Pointer(&x.refa05986e9.usb2))
}

// copyPU16Bytes copies the data from Go slice as *C.u16.
func copyPU16Bytes(slice *sliceHeader) (*C.u16, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfU16Value) * slice.Len,
		Cap:  int(sizeOfU16Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.u16)(mem0), allocs
}

// allocU16Memory allocates memory for type C.u16 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocU16Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfU16Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfU16Value = unsafe.Sizeof([1]C.u16{})

// copyPU32Bytes copies the data from Go slice as *C.u32.
func copyPU32Bytes(slice *sliceHeader) (*C.u32, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfU32Value) * slice.Len,
		Cap:  int(sizeOfU32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.u32)(mem0), allocs
}

// allocU32Memory allocates memory for type C.u32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocU32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfU32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfU32Value = unsafe.Sizeof([1]C.u32{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackArgSBeagleExt transforms a sliced Go data structure into plain C format.
func unpackArgSBeagleExt(x []BeagleExt) (unpacked *C.BeagleExt, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBeagleExtMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BeagleExt)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BeagleExt)(h.Data)
	return
}

// packSBeagleExt reads sliced Go data structure out from plain C format.
func packSBeagleExt(v []BeagleExt, ptr0 *C.BeagleExt) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBeagleExtValue]C.BeagleExt)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBeagleExtRef(unsafe.Pointer(&ptr1))
	}
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// unpackArgSBeagleVersion transforms a sliced Go data structure into plain C format.
func unpackArgSBeagleVersion(x []BeagleVersion) (unpacked *C.BeagleVersion, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocBeagleVersionMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BeagleVersion)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BeagleVersion)(h.Data)
	return
}

// packSBeagleVersion reads sliced Go data structure out from plain C format.
func packSBeagleVersion(v []BeagleVersion, ptr0 *C.BeagleVersion) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfBeagleVersionValue]C.BeagleVersion)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewBeagleVersionRef(unsafe.Pointer(&ptr1))
	}
}

// copyPBeagleCaptureStatusBytes copies the data from Go slice as *C.BeagleCaptureStatus.
func copyPBeagleCaptureStatusBytes(slice *sliceHeader) (*C.BeagleCaptureStatus, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfBeagleCaptureStatusValue) * slice.Len,
		Cap:  int(sizeOfBeagleCaptureStatusValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.BeagleCaptureStatus)(mem0), allocs
}

// allocBeagleCaptureStatusMemory allocates memory for type C.BeagleCaptureStatus in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBeagleCaptureStatusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBeagleCaptureStatusValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfBeagleCaptureStatusValue = unsafe.Sizeof([1]C.BeagleCaptureStatus{})

// copyPU64Bytes copies the data from Go slice as *C.u64.
func copyPU64Bytes(slice *sliceHeader) (*C.u64, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfU64Value) * slice.Len,
		Cap:  int(sizeOfU64Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.u64)(mem0), allocs
}

// allocU64Memory allocates memory for type C.u64 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocU64Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfU64Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfU64Value = unsafe.Sizeof([1]C.u64{})

// copyPF32Bytes copies the data from Go slice as *C.f32.
func copyPF32Bytes(slice *sliceHeader) (*C.f32, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfF32Value) * slice.Len,
		Cap:  int(sizeOfF32Value) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.f32)(mem0), allocs
}

// allocF32Memory allocates memory for type C.f32 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocF32Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfF32Value))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfF32Value = unsafe.Sizeof([1]C.f32{})
